* [单一职责](https://github.com/reallovelei/Design-patterns/blob/master/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99.md#单一职责)
* [里氏替换原则](https://github.com/reallovelei/Design-patterns/blob/master/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99.md#里氏替换原则)
* [依赖倒置原则](https://github.com/reallovelei/Design-patterns/blob/master/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99.md#依赖倒置原则)
* [接口隔离原则](https://github.com/reallovelei/Design-patterns/blob/master/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99.md#接口隔离原则)
* [迪米特法则](https://github.com/reallovelei/Design-patterns/blob/master/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99.md#迪米特法则)
* [开闭原则](https://github.com/reallovelei/Design-patterns/blob/master/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99.md#开闭原则)

## 概述
设计原则是从思想层面给我们指出设计的正确的方向，是我们进行面向对象分析设计时应该尽力遵守的准则。
> 提示:
> * 设计模式则对设计原则的一些具体实现。
> * 每一种模式 并不是单一的体现某个设计原则。事实上，很多模式都是融合了很多个设计原则的思想。
> * 这些原则只是一个建议指导。事实上，在实际开发中，很少做到完全遵守，总是在有意无意的违反一些或者是部分设计原则。
设计工作本来就是不断权衡的工作，有句话"设计是一种危险的权衡艺术"。

## 单一职责

### 定义
不要多于一个导致类变更的原因，通俗的说一个类只负责一项职责。(这里说的一项职责不是说 一个类只能有一个函数/方法,而是说负责一类的功能处理)

### 问题由来
类T负责两个不同的职责：职责P1，职责P2。当由于职责P1需求发生改变而需要修改类T时，有可能会导致原本运行正常的职责P2功能发生故障。

### 解决方案
遵循单一职责原则。分别建立两个类T1、T2，使T1完成职责P1功能，T2完成职责P2功能。这样，当修改类T1时，不会使职责P2发生故障风险；同理，当修改T2时，也不会使职责P1发生故障风险。

说到单一职责原则，很多人都会不屑一顾。因为它太简单了。稍有经验的程序员即使从来没有读过设计模式、从来没有听说过单一职责原则，在设计软件时也会自觉的遵守这一重要原则，因为这是常识。在软件编程中，谁也不希望因为修改了一个功能导致其他的功能发生故障。而避免出现这一问题的方法便是遵循单一职责原则。虽然单一职责原则如此简单，并且被认为是常识，但是即便是经验丰富的程序员写出的程序，也会有违背这一原则的代码存在。为什么会出现这种现象呢？因为有职责扩散。所谓职责扩散，就是因为某种原因，职责P被分化为粒度更细的职责P1和P2。

比如：类T只负责一个职责P，这样设计是符合单一职责原则的。后来由于某种原因，也许是需求变更了，也许是程序的设计者境界提高了，需要将职责P细分为粒度更细的职责P1，P2，这时如果要使程序遵循单一职责原则，需要将类T也分解为两个类T1和T2，分别负责P1、P2两个职责。但是在程序已经写好的情况下，这样做简直太费时间了。所以，简单的修改类T，用它来负责两个职责是一个比较不错的选择，虽然这样做有悖于单一职责原则。（这样做的风险在于职责扩散的不确定性，因为我们不会想到这个职责P，在未来可能会扩散为P1，P2，P3，P4……Pn。所以记住，在职责扩散到我们无法控制的程度之前，立刻对代码进行重构。）

举例说明，用一个类描述动物呼吸这个场景：

```java
class Animal{
    public void breathe(String animal){
      System.out.println(animal+"呼吸空气");
    }
}

public class Client{
    public static void main(String[] args){
      Animal animal = new Animal();
      animal.breathe("牛");
      animal.breathe("羊");
      animal.breathe("猪");
    }
}
```
运行结果：

牛呼吸空气

羊呼吸空气

猪呼吸空气

程序上线后，发现问题了，并不是所有的动物都呼吸空气的，比如鱼就是呼吸水的。修改时如果遵循单一职责原则，需要将Animal类细分为陆生动物类Terrestrial，水生动物Aquatic，代码如下：

```java
class Terrestrial{
    public void breathe(String animal){
        System.out.println(animal+"呼吸空气");
    }
}
class Aquatic{
    public void breathe(String animal){
        System.out.println(animal+"呼吸水");
    }
}

public class Client{
    public static void main(String[] args){
        Terrestrial terrestrial = new Terrestrial();
        terrestrial.breathe("牛");
        terrestrial.breathe("羊");
        terrestrial.breathe("猪");

        Aquatic aquatic = new Aquatic();
        aquatic.breathe("鱼");
    }
}
```
运行结果：

牛呼吸空气

羊呼吸空气

猪呼吸空气

鱼呼吸水

我们会发现如果这样修改花销是很大的，除了将原来的类分解之外，还需要修改客户端。而直接修改类Animal来达成目的虽然违背了单一职责原则，但花销却小的多，**我认为也违背了 开放封闭原则**代码如下：

```java
class Animal{
    public void breathe(String animal){
        if("鱼".equals(animal)){
            System.out.println(animal+"呼吸水");
        }else{
            System.out.println(animal+"呼吸空气");
        }
    }
}

public class Client{
    public static void main(String[] args){
        Animal animal = new Animal();
        animal.breathe("牛");
        animal.breathe("羊");
        animal.breathe("猪");
        animal.breathe("鱼");
    }
}
```

可以看到，这种修改方式要简单的多。但是却存在着隐患：有一天需要将鱼分为呼吸淡水的鱼和呼吸海水的鱼，则又需要修改Animal类的breathe方法，而对原有代码的修改会对调用“猪”“牛”“羊”等相关功能带来风险，也许某一天你会发现程序运行的结果变为“牛呼吸水”了。这种修改方式直接在代码级别上违背了单一职责原则，虽然修改起来最简单，但隐患却是最大的。

还有一种修改方式 方法级别的单一职责：
```java
class Animal{
    public void breathe(String animal){
        System.out.println(animal+"呼吸空气");
    }

    public void breathe2(String animal){
        System.out.println(animal+"呼吸水");
    }
}

public class Client{
    public static void main(String[] args){
        Animal animal = new Animal();
        animal.breathe("牛");
        animal.breathe("羊");
        animal.breathe("猪");
        animal.breathe2("鱼");
    }
}
```
可以看到，这种修改方式没有改动原来的方法，而是在类中新加了一个方法，这样虽然也违背了单一职责原则，但在方法级别上却是符合单一职责原则的，因为它并没有动原来方法的代码。这三种方式各有优缺点，那么在实际编程中，采用哪一中呢？其实这真的比较难说，需要根据实际情况来确定。我的原则是：只有逻辑足够简单，才可以在代码级别上违反单一职责原则；只有类中方法数量足够少，才可以在方法级别上违反单一职责原则；

例如本文所举的这个例子，它太简单了，它只有一个方法，所以，无论是在代码级别上违反单一职责原则，还是在方法级别上违反，都不会造成太大的影响。实际应用中的类都要复杂的多，一旦发生职责扩散而需要修改类时，除非这个类本身非常简单，否则还是遵循单一职责原则的好。

### 遵循单一职责原的优点

> * 可以降低类的复杂度，一个类只负责一项职责，其逻辑肯定要比负责多项职责简单的多；
> * 提高类的可读性，提高系统的可维护性；
> * 变更引起的风险降低，变更是必然的，如果单一职责原则遵守的好，当修改一个功能时，可以显著降低对其他功能的影响。

需要说明的一点是单一职责原则不只是面向对象编程思想所特有的，只要是模块化的程序设计，都适用单一职责原则。
话说 我怎么觉得这个单一职责 和 开放封闭原则有点遥相呼应的赶脚。。

## 里氏替换原则
### 定义
所有引用基类的地方必须能透明地使用其子类的对象。

### 问题由来
有一功能P1，由类A完成。现需要将功能P1进行扩展，扩展后的功能为P，其中P由原有功能P1与新功能P2组成。新功能P由类A的子类B来完成，则子类B在完成新功能P2的同时，有可能会导致原有功能P1发生故障。


### 解决方案
当使用继承时，遵循里氏替换原则。类B继承类A时，除添加新的方法完成新增功能P2外，尽量不要重写父类A的方法，也尽量不要重载父类A的方法。
### 优点


## 依赖倒置原则
### 定义
高层模块不应该依赖底层模块，两者都应该依赖于抽象。

**我的理解这个原则就应该叫做依赖抽象原则，倒置是什么意思一直也没太明白。**
>相对于细节的多变性，抽象的东西要稳定的多。以抽象为基础搭建起来的架构比以细节为基础搭建起来的架构要稳定的多。在java中，抽象指的是接口或者抽象类，细节就是具体的实现类，使用接口或者抽象类的目的是制定好规范和契约，而不去涉及任何具体的操作，把展现细节的任务交给他们的实现类去完成。

### 问题由来
类A直接依赖类B，假如要将类A改为依赖类C，则必须通过修改类A的代码来达成。这种场景下，类A一般是高层模块，负责复杂的业务逻辑；类B和类C是低层模块，负责基本的原子操作；假如修改类A，会给程序带来不必要的风险。
### 解决方案
将类A修改为依赖接口I，类B和类C各自实现接口I，类A通过接口I间接与类B或者类C发生联系，则会大大降低修改类A的几率。 如我们现在代码中的controller层 就只依赖 service 这样controller就很少会修改了。 用的是这个思想. 但是没有严格按照这个原则来执行.

### 举例
依赖倒置原则的核心思想是面向接口编程，我们依旧用一个例子来说明面向接口编程比相对于面向实现编程好在什么地方。场景是这样的，母亲给孩子讲故事，只要给她一本书，她就可以照着书给孩子讲故事了。代码如下：

```java
class Book{
    public String getContent(){
        return "很久很久以前有一个阿拉伯的故事……";
    }
}

class Mother{
    public void narrate(Book book){
        System.out.println("妈妈开始讲故事");
        System.out.println(book.getContent());
    }
}

public class Client{
    public static void main(String[] args){
        Mother mother = new Mother();
        mother.narrate(new Book());
    }
}
```
运行结果：

妈妈开始讲故事

很久很久以前有一个阿拉伯的故事……

运行良好，假如有一天，需求变成这样：不是给书而是给一份报纸，让这位母亲讲一下报纸上的故事，报纸的代码如下：
```java
class Newspaper{
    public String getContent(){
        return "林书豪38+7领导尼克斯击败湖人……";
    }
}
```
这位母亲却办不到，因为她居然不会读报纸上的故事，这太荒唐了，只是将书换成报纸，居然必须要修改Mother才能读。假如以后需求换成杂志呢？换成网页呢？还要不断地修改Mother，这显然不是好的设计。原因就是Mother与Book之间的耦合性太高了，必须降低他们之间的耦合度才行。

我们引入一个抽象的接口IReader。读物，只要是带字的都属于读物：
```java
interface IReader{
    public String getContent();
}
```
Mother类与接口IReader发生依赖关系，而Book和Newspaper都属于读物的范畴，他们各自都去实现IReader接口，这样就符合依赖倒置原则了，代码修改为：
```java
class Newspaper implements IReader {
    public String getContent(){
        return "林书豪17+9助尼克斯击败老鹰……";
    }
}
class Book implements IReader{
    public String getContent(){
        return "很久很久以前有一个阿拉伯的故事……";
    }
}

class Mother{
    public void narrate(IReader reader){
        System.out.println("妈妈开始讲故事");
        System.out.println(reader.getContent());
    }
}

public class Client{
    public static void main(String[] args){
        Mother mother = new Mother();
        mother.narrate(new Book());
        mother.narrate(new Newspaper());
    }
}
```
运行结果：

妈妈开始讲故事

很久很久以前有一个阿拉伯的故事……

妈妈开始讲故事

林书豪17+9助尼克斯击败老鹰……

这样修改后，无论以后怎样扩展Client类，都不需要再修改Mother类了。这只是一个简单的例子，实际情况中，代表高层模块的Mother类将负责完成主要的业务逻辑，一旦需要对它进行修改，引入错误的风险极大。所以遵循依赖倒置原则可以降低类之间的耦合性，提高系统的稳定性，降低修改程序造成的风险。


### 优点
采用依赖倒置原则给多人并行开发带来了极大的便利，比如上例中，原本Mother类与Book类直接耦合时，Mother类必须等Book类编码完成后才可以进行编码，因为Mother类依赖于Book类。修改后的程序则可以同时开工，互不影响，因为Mother与Book类一点关系也没有。参与协作开发的人越多、项目越庞大，采用依赖导致原则的意义就越重大。现在很流行的TDD开发模式就是依赖倒置原则最成功的应用。

**传递依赖的方式**
-----------------
1. 接口传递[上例中]
2. 构造方法传递
3. setter方法传递

**注意**
-----------------
> 在实际编程中，我们一般需要做到如下3点：
> * 低层模块尽量都要有抽象类或接口，或者两者都有。
> * 变量的声明类型尽量是抽象类或接口。 (???是指类里的变量吗)
> * 使用继承时遵循里氏替换原则。  
其实说了这么多就像我上面说的, 依赖倒置原则的核心就是要我们面向接口编程，理解了面向接口编程，也就理解了依赖倒置。


## 接口隔离原则
### 定义
客户端不应该依赖它不需要的接口；一个类对另一个类的依赖应该建立在最小的接口上。 (这尼玛不是废话么)

### 问题由来
类A通过接口I依赖类B，类C通过接口I依赖类D，如果接口I对于类A和类B来说不是最小接口，则类B和类D必须去实现他们不需要的方法。
### 解决方案
将臃肿的接口I拆分为独立的几个接口，类A和类C分别与他们需要的接口建立依赖关系。也就是采用接口隔离原则。

### 优点

## 迪米特法则
### 定义
### 问题由来
### 解决方案
### 优点

## 开闭原则
### 定义
### 问题由来
### 解决方案
### 优点
