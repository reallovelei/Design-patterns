## IOC控制反转
控制反转即IOC(inversion of control),它把传统上由程序代码直接操控的对象的调用权交给容器。通过容器来实现对象组件的装配和管理。所谓"控制反转"概念就是对组件对象控制权的转移，从程序代码本身转移到了外部容器。  
IOC是一个思想，可以用不同方式来实现。主要有两种方式:  
1. 依赖查找(Dependency Lookup):容器提供回调接口及上下文给组件。  
2. 依赖注入(Dependency Injection):组件不做定位查询，只提供方法让容器去决定依赖关系。这是时下最流行的IOC实现方式。  
3. 还有接口注入(Interface Injection)、设值注入(Setter Injection)、构造注入(Constructor Injection)等。  

依赖注入之所以流行是因为他是一种更可取的方式：让容器全权负责依赖查询，受管组件只需要暴露setter方法，使容器可以在初始化时组装对象的依赖关系。  
其与依赖查找方式相比，主要优势为:  
* 查找定位操作与应用代码完全无关。
* 不依赖于容器的API，可以很容易的在任何容器以外使用应用对象。
* 不需要特殊的接口，大多数对象可以做到完全不必依赖容器。

## 好莱坞原则
IOC体现了好莱坞原则(不要找我们，我们找你)。第一次遇到好莱坞原则是在了解模板方法的时候，模板方法模式作为父类的模板会在需要的调用子类的方法，也就是由父类去找子类，而不是子类找父类。这也是一种反向的控制结构，通常是子类找父类，也就是说是子类调用父类的方法，因为父类根本不知道子类，而子类是知道父类的。  
模板方法的核心是:基类(抽象类)定义了算法的骨架，而将一些步骤延迟到子类中。使得子类不改变算法的结构即可重新定义该算法的某些特定步骤。  
现在来考虑IOC的实现机制，组件定义了整个流程框架，而其中的一些业务逻辑的实现要借助于其他业务对象的加入，它们可以通过依赖注入参与到业务流程中来。  

## 依赖注入
**基本原则**：应该组件不应该负责查找资源或其他依赖的协作对象。配置对象的工作应该由IOC容器负责，“查找资源”的逻辑应该从应用组件的代码中抽取出来，交给IOC容器负责。  
**依赖注入的意义**：让组件依赖于抽象，当组件要与其他对象发生依赖关系时，通过抽象来注入依赖的实际对象。  
依赖注入实现的方式一般有如下3种：  
1. 构造注入  
```php
Class Context {
    private $_strategy;
    funciont __construct(Strategy $strategy) {
        $this->_strategy = $strategy;
    }
}
$obj = new Context($strategy);
```
2. 设值注入  
```php
Class Context {
    private $_strategy;
    funciont Setter(Strategy $strategy) {
        $this->_strategy = $strategy;
    }
}
$obj = new Context();
$obj->Setter($strategy);
```

3. 接口注入  
```php
Interface ICon {
    function Setter(Strategy $strategy);
}
```

这怎么看着和依赖倒置有点像呢？醉了 明天仔细比较一下吧。
