# 外观模式

## 定义:  
为子系统定义一组接口提供一个一致界面，外观模式提供了一个高层接口，这个接口使得子系统更加容易使用。  

## 认识外观模式
1. 目的  
外观模式并不是给子系统增加新的功能，而是为了让外部减少与子系统的内部交互，达到松散耦合,从而让外部更简单方便的使用子系统。
2. 使用和不使用的变化  
    看到外观的实现感觉就像是把客户端的代码拿到Facade里去了。没错，就是这样。仔细思考会发现Facade是模块组成的系统这边的，而不是客户端那边的。  
在系统这边就屏蔽了客户端对系统内部的交互，类似一层代理。把内部模块作为一个整体展现给客户端。而客户端不需要具体知道内部有哪些模块需要挨个调用。
3. 有外观,但是可以不使用  
    如果有需要，外部还是可以绕开Facade。直接调用系统内部某个模块。这样可以兼顾整体组合功能和细节功能。

## 优点与缺点
### 优点
* 松散耦合
外观松散了外部(客户端)与子系统内部的关系，让子系统内部的可扩展性、可维护性更好。
* 简单易用
客户端不再需要和子系统内部的组成模块直接交互。而是和Facade交互就可以了，相当于Facade给子系统提供了一站式服务(我感觉就是做了一层代理服务,做了一层封装而已)。
* 更好的划分访问层次
通过Facade可以帮助我们更好的划分访问的层次。有些方法是对系统外的，有些方法是系统内部使用的。把需要对外部暴露的方法集中到Facade中，这样既方便了客户端的使用。也隐藏了系统的内部实现。

### 缺点
* 过多或不合理的使用外观,也会让人感到迷惑，到底是使用外观好呢，还是直接调用好呢。

## 思考
1. 外观模式的本质是：封装交互，简化调用。
2. 对设计原则的体现：外观很好的体现了[最少知道原则](https://github.com/reallovelei/Design-patterns/blob/master/principle/%E8%BF%AA%E7%B1%B3%E7%89%B9%E6%B3%95%E5%88%99-%E6%9C%80%E5%B0%91%E7%9F%A5%E9%81%93%E5%8E%9F%E5%88%99.md)。前面说了很多 客户端只和外观类有依赖关系，无需关心系统内部模块。
3. 何时选用外观模式
* 如果你希望为一个复杂的子系统提供一个简单的外部访问接口的时候。
* 如果想让客户端和抽象类的实现部分松散耦合的时候。可以使用外观将客户端与子系统分离开来，从而提高子系统的可移植性和独立性。
* 如果构建多层架构的系统，可以考虑使用外观来做层间调用关系。

## 相关模式
* 外观和中介者
* 外观和单例
* 外观和抽象工厂
